This is a project in which I create a movie recomendation system. The program propmts the user to give movies a rank and then based on the user input will give a movie recommendation. 

The idea behind this application was to create a movie recommendation system that utilizes both collaborative and content-based filtering. The purpose of the application is to provide users with more personalized and accurate movie recommendations based on how a user is feeling when using the movie recommendation application. Users are asked to select their preferred movie genre, rate 3 movies in that genre, and specify their preferred release year range. The recommendation algorithm then calculates similarity scores between users based on their ratings and suggests the top-rated movies that the user is most likely to enjoy. 
The inspiration behind this project was creating a better recommendation system than what is already out there on Apps like Netflix and other streaming services. The data used was the MovieLens dataset collected by the GroupLens Research Team. The explanation of the functions in the code are below.
1.	get_genre_preferences(): This function prompts the user to input their preferred movie genre. It first calculates the top 100 genres in the dataset (based on how frequently they appear), then prints these genres for the user to choose from. The user's selected genre is returned.
2.	filter_data_by_genre(preferred_genre, min_year, max_year): This function filters the movie dataset based on the user's preferred genre and the range of release years. It first filters movies that contain the preferred genre. Then, it filters the genre-specific movies based on the user's preferred range of release years. It also filters movies based on a rating threshold to ensure recommended movies have a minimum average rating. Finally, it returns the filtered movies and their ratings.
3.	get_movie_to_rate(user_id): This function selects a random movie that the user has not yet rated, and returns its title.
4.	get_year_range(): This function prompts the user to input their preferred range of movie release years. It asks the user for a minimum and maximum year and returns these values.
5.	get_user_ratings(preferred_genre, min_year, max_year): This function gets the user's ratings for three movies. It first filters movies based on the user's preferred genre and release years. If no movies match the user's preferences, it informs the user and returns an empty list. Otherwise, it calculates the average rating of each movie, sorts the movies by rating, and prompts the user to rate three of these movies. It returns a list of tuples, where each tuple contains a movie ID and the user's rating for that movie.
6.	assign_user_id(user_ratings): This function assigns the user a user ID based on the correlation between their ratings and the ratings of existing users. For each existing user who has rated at least one movie that the new user has rated, it calculates the Pearson correlation coefficient between their ratings. The user ID of the existing user with the highest correlation is assigned to the new user and returned.
7.	hybrid_recommendations(user_id, user_ratings): This function generates hybrid recommendations for the user. It estimates the user's rating for each movie that is similar to the movies they've rated, using the SVD model. The estimated ratings are sorted in descending order, and the titles of the top 10 movies are returned as recommendations.
8.	get_similar_movie(movie_id, k=50): This function returns the indices of the top k movies that are most similar to the given movie, based on cosine similarity. The cosine similarity scores are sorted in descending order, and the indices of the top k movies are returned.
9.	main(): This function is the main driver of the program. It loads the datasets, preprocesses the data, computes the TF-IDF matrix and cosine similarity matrix, prepares the ratings data for Surprise, splits the data into training and testing sets, and trains the SVD model. It then prompts the user for their genre preferences and preferred range of release years, gets their ratings for three movies, assigns them a user ID, and generates hybrid recommendations for them. The recommended movies are printed to the console.
Surprise Python Package:
The surprise library is a Python scikit used for building and analyzing recommender systems. surprise stands for Simple Python Recommendation System Engine.
It provides various ready-to-use prediction algorithms including matrix factorization-based algorithms, neighborhood-based algorithms, and others. It also provides tools to evaluate, analyse, and compare the performance of different algorithms. The name of the library comes from the fact that recommender systems are often used for generating "surprise" recommendations for users.

What is SVD?
Singular Value Decomposition (SVD) is a matrix factorization technique that is commonly used in recommendation systems. It's particularly popular for collaborative filtering in which the goal is to predict users' ratings of items.
The fundamental idea behind SVD is that it can decompose a matrix into three separate matrices:
•	A left singular matrix, which represents the relationships between rows (in this case, users)
•	A diagonal matrix, which represents the strengths of latent (or hidden) factors
•	A right singular matrix, which represents the relationships between columns (in this case, items or movies)
In the context of a movie recommendation system, SVD works as follows:
1.	The original matrix is the user-item ratings matrix where each row represents a user, each column represents a movie, and each cell represents a rating. Many of these cells are often missing because not all users rate all movies.
2.	SVD decomposes this matrix into the three mentioned matrices. The first matrix represents the weights of each latent factor for each user, the second matrix (the diagonal matrix) represents the strengths of each of these latent factors, and the third matrix represents the weights of each latent factor for each item (movie).
3.	When predicting a rating, SVD takes a user's row from the first matrix and an item's column from the third matrix, then takes the dot product of these two vectors to obtain a prediction. This operation essentially computes a weighted sum of the ratings of all other items by all other users, where the weights are determined by how similar the users/items are to the user/item of interest.
The SVD algorithm learns the optimal weights for each latent factor during training. This is usually done using stochastic gradient descent or another optimization algorithm.
One of the biggest advantages of using SVD in a recommendation system is that it can handle sparse data, which is typically a problem in user-item interactions. Not all users will rate all items, leading to a lot of missing values. SVD is capable of predicting these missing values by learning the latent preferences of users and characteristics of items.

Here's the mathematical formula for cosine similarity:
Cosine Similarity

Cosine_Similarity(A, B) = Dot_Product(A, B) / ||A|| * ||B||
In the context of a recommendation system, a vector could represent a user's ratings of different items, or a movie's genre represented in binary (1 if the movie belongs to the genre, 0 if not). Cosine similarity can then be used to find the most similar users or movies.
For example, if you have a matrix where each row represents a movie and each column represents a different genre, you can calculate the cosine similarity between each pair of rows (movies) to find the movies with the most similar genre profiles. This is exactly what the line cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix) in your provided code is doing: it's computing the cosine similarity between each pair of movies based on their genre representation in the TF-IDF matrix.
TF-IDF stands for Term Frequency-Inverse Document Frequency. It's a statistical measure used to evaluate the importance of a word in a document, which is part of a collection or corpus. The importance of the word increases proportionally to the number of times a word appears in the document but is offset by the frequency of the word in the corpus.
The TfidfVectorizer is used to transform the 'genres' column of the 'movies' dataframe into a TF-IDF matrix. This means that each genre is considered a "word", and each movie is considered a "document". The TF-IDF matrix then represents each movie as a vector in a multi-dimensional space, where each dimension corresponds to a genre, and the value in each dimension is the TF-IDF value of that genre for that movie.
This TF-IDF matrix can then be used to calculate similarity between movies based on their genre profiles, which is what the cosine similarity function does. It's a commonly used approach in information retrieval and text mining. It helps to highlight the movies that have a unique genre distribution.
Overall, the application works well and I am happy with the results. The biggest limitation was not being able to use the full data set due to not having enough computing power but that is something I will continue to work on. 

